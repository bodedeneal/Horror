<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Horror Game</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: #111;
      cursor: crosshair;
    }
    #hud {
      position: absolute;
      left: 10px;
      top: 10px;
      color: #fff;
      font-family: monospace;
      z-index: 10;
    }
    #deathscreen {
      position: fixed;
      left: 0; top: 0;
      width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.98);
      display: flex; align-items: center; justify-content: center;
      z-index: 9999;
      font-size: 5vw;
      color: red;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
      flex-direction: column;
      font-family: 'Creepster', 'Arial Black', sans-serif;
      text-shadow: 4px 4px 10px #000, 0 0 40px #d00;
    }
    #deathscreen .monster {
      font-size: 10vw; margin-bottom: 1em;
      animation: grab 1s cubic-bezier(.72,.11,.77,1.55);
    }
    @keyframes grab {
      0% { transform: scale(0) translateY(300px);}
      50% { transform: scale(1.2) translateY(-10px);}
      100% { transform: scale(1) translateY(0);}
    }
  </style>
  <!-- Creepster font for extra horror vibes -->
  <link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="hud">WASD to move, Mouse to look, Shift+Mouse up/down to look up/down.</div>
  <div id="deathscreen">
    <div class="monster">üï∑Ô∏è</div>
    <div>You have been caught.<br>The monster grabs you and you die!</div>
    <div style="font-size:2vw;margin-top:2em;">Refresh to try again.</div>
  </div>
  <script>
    // ---------------- GAME CONFIG ----------------
    // Map legend:
    // "1" - normal wall (red)
    // "0" - empty
    // "2" - white wall
    // "U" - rising wall (green, goes up in front of player)
    const map = [
      "111111111111",
      "100000000001",
      "101110111101",
      "100100100001",
      "101100101101",
      "100000000001",
      "101111111101",
      "100222200001", // <-- white area (2)
      "111111111111"
    ];
    const TILE_SIZE = 1.0;
    const MAP_W = map[0].length;
    const MAP_H = map.length;
    const FOV = Math.PI/3;
    const NUM_RAYS = 160;
    const PLAYER = {
      x: 2, y: 2,
      dir: 0,
      fov: FOV,
      speed: 0.08,
      rotSpeed: 0.045,
      pitch: 0, // -1 (look up) to 1 (look down)
      pitchSpeed: 0.03,
      alive: true
    };

    // Monster: 3D horror version, follows and kills player
    let monster = {
      x: 8, y: 6,
      speed: 0.02,
      active: true,
      grabbing: false,
      grabProgress: 0 // 0 to 1 for grab animation
    };

    // Rising wall (green)
    let risingWall = {
      active: false,
      x: null,
      y: null,
      height: 0, // 0 = hidden, 1 = fully up
      risingSpeed: 0.06
    };

    function updateRisingWall() {
      let fx = PLAYER.x + Math.cos(PLAYER.dir);
      let fy = PLAYER.y + Math.sin(PLAYER.dir);
      let wallX = Math.floor(fx);
      let wallY = Math.floor(fy);
      if (
        wallX > 0 && wallX < MAP_W-1 &&
        wallY > 0 && wallY < MAP_H-1 &&
        map[wallY][wallX] === '0'
      ) {
        risingWall.x = wallX;
        risingWall.y = wallY;
        risingWall.active = true;
      } else {
        risingWall.active = false;
        risingWall.x = null;
        risingWall.y = null;
        risingWall.height = 0;
      }
    }
    function animateRisingWall() {
      if (risingWall.active && risingWall.height < 1) {
        risingWall.height += risingWall.risingSpeed;
        if (risingWall.height > 1) risingWall.height = 1;
      }
    }

    // ---------------- INPUT ----------------
    let keys = {};
    document.addEventListener('keydown', e => keys[e.code]=true);
    document.addEventListener('keyup', e => keys[e.code]=false);
    let mouseCaptured = false;
    document.body.onclick = () => {
      gameCanvas.requestPointerLock();
    };
    document.addEventListener('pointerlockchange', () => {
      mouseCaptured = document.pointerLockElement === gameCanvas;
    });
    document.addEventListener('mousemove', e => {
      if(mouseCaptured && PLAYER.alive) {
        PLAYER.dir += e.movementX * -0.002;
        if(keys["ShiftLeft"] || keys["ShiftRight"]) {
          PLAYER.pitch += e.movementY * -0.002;
          PLAYER.pitch = Math.max(-0.75, Math.min(0.75, PLAYER.pitch));
        }
      }
    });

    // ---------------- RAYCASTING RENDER ----------------
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function castRay(x, y, angle) {
      let sin = Math.sin(angle), cos = Math.cos(angle);
      let dist = 0, hit = false, type = '0';
      let step = 0.01;
      while(!hit && dist < 20) {
        let nx = x + cos*dist, ny = y + sin*dist;
        let mx = Math.floor(nx), my = Math.floor(ny);

        if (
          risingWall.active &&
          mx === risingWall.x &&
          my === risingWall.y &&
          risingWall.height > 0.01
        ) {
          hit = true;
          type = 'U';
        }
        if(mx<0||my<0||mx>=MAP_W||my>=MAP_H) {
          hit=true; type='1';
        }
        else if(map[my][mx]==='1') {
          hit=true; type='1';
        }
        else if(map[my][mx]==='2') {
          hit=true; type='2';
        }
        dist += step;
      }
      return {dist, type};
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      let pitchOffset = PLAYER.pitch * canvas.height * 0.34;

      // Draw 3D walls
      for(let i=0; i<NUM_RAYS; i++) {
        let rayAngle = PLAYER.dir - FOV/2 + FOV*i/NUM_RAYS;
        let {dist, type} = castRay(PLAYER.x, PLAYER.y, rayAngle);
        dist *= Math.cos(rayAngle-PLAYER.dir);

        let wallHeight;
        if(type === 'U') {
          wallHeight = canvas.height/(dist+0.1) * risingWall.height;
        } else {
          wallHeight = canvas.height/(dist+0.1);
        }

        if(type === '1') {
          let shade = Math.max(0, 180-dist*12);
          ctx.fillStyle = `rgb(${shade},0,0)`;
        } else if(type === '2') {
          ctx.fillStyle = "#fff";
        } else if(type === 'U') {
          ctx.fillStyle = "limegreen";
        }

        ctx.fillRect(
          i*canvas.width/NUM_RAYS,
          canvas.height/2-wallHeight/2 + pitchOffset,
          canvas.width/NUM_RAYS+1,
          wallHeight
        );
      }

      // Monster: 3D billboard, grows if grabbing
      if(monster.active) {
        let dx = monster.x-PLAYER.x, dy = monster.y-PLAYER.y;
        let dist = Math.sqrt(dx*dx+dy*dy);
        let angToMonster = Math.atan2(dy,dx);
        let relAngle = angToMonster-PLAYER.dir;
        if(dist<20 && Math.abs(relAngle)<FOV/2) {
          let px = (relAngle+FOV/2)/FOV*canvas.width;
          let size;
          if(monster.grabbing) {
            // Animate monster growing during grab
            size = Math.min(canvas.height, 300/(dist+0.1) + monster.grabProgress*canvas.height*0.8);
          } else {
            size = Math.min(220, 500/(dist+0.1));
          }
          ctx.save();
          ctx.globalAlpha = monster.grabbing ? 1 : Math.max(0.1, 0.8-dist/10);
          ctx.drawImage(monsterImage, px-size/2, canvas.height/2-size/2 + pitchOffset, size, size);
          ctx.restore();
        }
      }

      // Floor and ceiling
      ctx.fillStyle = "#222";
      ctx.fillRect(0,canvas.height/2+pitchOffset,canvas.width,canvas.height/2-pitchOffset);
      ctx.fillStyle = "#070707";
      ctx.fillRect(0,0,canvas.width,canvas.height/2+pitchOffset);
    }

    // ---------------- GAME LOGIC ----------------
    function update() {
      if (!PLAYER.alive) return;
      updateRisingWall();
      animateRisingWall();

      // Movement
      let moveX=0, moveY=0;
      if(keys["KeyW"]) { moveX+=Math.cos(PLAYER.dir)*PLAYER.speed; moveY+=Math.sin(PLAYER.dir)*PLAYER.speed; }
      if(keys["KeyS"]) { moveX-=Math.cos(PLAYER.dir)*PLAYER.speed; moveY-=Math.sin(PLAYER.dir)*PLAYER.speed; }
      if(keys["KeyA"]) { moveX+=Math.cos(PLAYER.dir-Math.PI/2)*PLAYER.speed; moveY+=Math.sin(PLAYER.dir-Math.PI/2)*PLAYER.speed; }
      if(keys["KeyD"]) { moveX+=Math.cos(PLAYER.dir+Math.PI/2)*PLAYER.speed; moveY+=Math.sin(PLAYER.dir+Math.PI/2)*PLAYER.speed; }
      let nx = PLAYER.x+moveX, ny = PLAYER.y+moveY;

      let mx = Math.floor(nx), my = Math.floor(ny);
      let block = false;
      if(map[my] && map[my][mx] === '1') block = true;
      if(map[my] && map[my][mx] === '2') block = true;
      if(risingWall.active && mx === risingWall.x && my === risingWall.y && risingWall.height > 0.8) block = true;
      if(!block) {
        PLAYER.x = nx;
        PLAYER.y = ny;
      }

      // Monster AI: move toward player, grab and kill
      if(monster.active && !monster.grabbing) {
        let dx = PLAYER.x-monster.x, dy = PLAYER.y-monster.y;
        let dist = Math.sqrt(dx*dx+dy*dy);
        if(dist > 0.32) {
          monster.x += dx/dist*monster.speed;
          monster.y += dy/dist*monster.speed;
        } else {
          // Initiate grab sequence!
          monster.grabbing = true;
          monster.grabProgress = 0;
        }
      }

      // Grab/kill animation
      if (monster.grabbing) {
        monster.grabProgress += 0.025;
        if (monster.grabProgress >= 1) {
          monster.grabProgress = 1;
          killPlayer();
        }
      }
    }

    function killPlayer() {
      PLAYER.alive = false;
      // Show death screen
      const ds = document.getElementById('deathscreen');
      ds.style.opacity = 1;
      ds.style.pointerEvents = 'auto';
      // Optional: play sound, shake, etc.
    }

    // ---------------- MONSTER SPRITE ----------------
    const monsterImage = new Image();
    monsterImage.src = "data:image/svg+xml;base64," +
      btoa(`<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200">
        <ellipse cx="100" cy="110" rx="55" ry="80" fill="#222" stroke="black" stroke-width="8"/>
        <ellipse cx="100" cy="105" rx="45" ry="75" fill="black" stroke="limegreen" stroke-width="8"/>
        <ellipse cx="100" cy="165" rx="31" ry="8" fill="limegreen" stroke="black" stroke-width="2"/>
        <ellipse cx="100" cy="155" rx="17" ry="3" fill="red"/>
        <circle cx="80" cy="90" r="14" fill="white" stroke="black" stroke-width="4"/>
        <circle cx="120" cy="90" r="14" fill="white" stroke="black" stroke-width="4"/>
        <ellipse cx="80" cy="90" rx="7" ry="10" fill="red"/>
        <ellipse cx="120" cy="90" rx="7" ry="10" fill="red"/>
        <ellipse cx="100" cy="120" rx="37" ry="8" fill="black"/>
        <ellipse cx="100" cy="126" rx="25" ry="4" fill="#222"/>
        <ellipse cx="100" cy="135" rx="17" ry="5" fill="limegreen"/>
      </svg>`);

    // ---------------- MAIN LOOP ----------------
    function gameLoop() {
      update();
      render();
      requestAnimationFrame(gameLoop);
    }
    gameLoop();
  </script>
</body>
</html>
