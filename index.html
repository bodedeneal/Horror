<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Maze Horror Game</title>
  <style>
    body, html { margin:0; padding:0; overflow:hidden; background:#000;}
    #bgStars {
      position:fixed; left:0; top:0; z-index:0;
      width:100vw; height:100vh; pointer-events:none;
    }
    #gameCanvas {
      position:fixed; left:0; top:0; z-index:1;
      width:100vw; height:100vh; background:transparent;
    }
    #hud {
      position:absolute; left:10px; top:10px; color:#fff;
      font-family:monospace; z-index:10; text-shadow:0 0 10px #000;
    }
    #minimap {
      position:absolute; right:10px; bottom:10px; z-index:10;
      background:rgba(0,0,0,0.7); border-radius:8px;
      padding:5px; box-shadow:0 0 6px #222;
    }
    #deathscreen {
      position:fixed; left:0; top:0; width:100vw; height:100vh;
      background:rgba(0,0,0,0.98); display:flex; align-items:center; justify-content:center;
      z-index:9999; font-size:5vw; color:red; opacity:0; pointer-events:none;
      transition:opacity 0.5s; flex-direction:column;
      font-family:'Creepster','Arial Black',sans-serif; text-shadow:4px 4px 10px #000,0 0 40px #d00;
    }
    #deathscreen .monster {
      font-size:10vw; margin-bottom:1em;
      animation:grab 1s cubic-bezier(.72,.11,.77,1.55);
    }
    @keyframes grab {
      0% { transform:scale(0) translateY(300px);}
      50% { transform:scale(1.2) translateY(-10px);}
      100% { transform:scale(1) translateY(0);}
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
</head>
<body>
  <canvas id="bgStars"></canvas>
  <canvas id="gameCanvas"></canvas>
  <div id="hud">
    WASD to move, Mouse to look, Shift+Mouse up/down to look up/down.<br>
    Try to escape the monster!<br>
    <span id="coords"></span>
  </div>
  <canvas id="minimap" width="128" height="80"></canvas>
  <div id="deathscreen">
    <div class="monster">üï∑Ô∏è</div>
    <div>You have been caught.<br>The monster grabs you and you die!</div>
    <div style="font-size:2vw;margin-top:2em;">Refresh to try again.</div>
  </div>
  <script>
  // ------ STAR BACKGROUND ------
  const bgStars = document.getElementById('bgStars');
  const bgCtx = bgStars.getContext('2d');
  function resizeBgStars() {
    bgStars.width = window.innerWidth;
    bgStars.height = window.innerHeight;
    drawStars();
  }
  function drawStars() {
    const w = bgStars.width, h = bgStars.height;
    bgCtx.clearRect(0,0,w,h);
    for(let i=0;i<220;i++){
      let x = Math.random()*w, y = Math.random()*h;
      let r = Math.random()*2+0.3;
      bgCtx.beginPath();
      bgCtx.arc(x,y,r,0,Math.PI*2);
      bgCtx.fillStyle = `rgba(255,255,255,${Math.random()*0.8+0.2})`;
      bgCtx.fill();
    }
  }
  window.addEventListener('resize', resizeBgStars);
  resizeBgStars();

  // ------ 2D MAZE MAP ------
  // Legend: 0=floor, 1=wall, 2=white wall
  // Walls are thick (player radius == wall thickness)
  const maze = [
    "1111111111111111111111",
    "1000000000000000000001",
    "1011110111110111111101",
    "1020000000010000000201",
    "1011111011011011111101",
    "1000001000010001000001",
    "1111101011111010111101",
    "1000001000000010000001",
    "1011101110111011111101",
    "1002222000000022220001",
    "1011111111111111111101",
    "1000000000000000000001",
    "1111111111111111111111"
  ];
  const MAP_W = maze[0].length, MAP_H = maze.length;
  const TILE_SIZE = 1.0; // player radius = 0.5, so wall "thickness" == player

  // ------ PLAYER ------
  const PLAYER = {
    x:2, y:2, dir:0, pitch:0, fov:Math.PI/3,
    speed:0.08, rotSpeed:0.045, pitchSpeed:0.03, radius:0.5, alive:true
  };

  // ------ MONSTER ------
  let monster = {
    x:MAP_W-3, y:MAP_H-3, speed:0.022, active:true, grabbing:false, grabProgress:0
  };

  // ------ INPUT ------
  let keys = {};
  document.addEventListener('keydown', e => keys[e.code]=true);
  document.addEventListener('keyup', e => keys[e.code]=false);
  let mouseCaptured = false;
  document.body.onclick = () => { gameCanvas.requestPointerLock(); };
  document.addEventListener('pointerlockchange', () => {
    mouseCaptured = document.pointerLockElement === gameCanvas;
  });
  document.addEventListener('mousemove', e => {
    if(mouseCaptured && PLAYER.alive) {
      PLAYER.dir += e.movementX * -0.002;
      if(keys["ShiftLeft"] || keys["ShiftRight"]) {
        PLAYER.pitch += e.movementY * -0.002;
        PLAYER.pitch = Math.max(-0.75, Math.min(0.75, PLAYER.pitch));
      }
    }
  });

  // ------ CANVAS SETUP ------
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // ------ RAYCASTING ------
  const NUM_RAYS = 240;
  function wallAt(x, y) {
    let mx = Math.floor(x), my = Math.floor(y);
    if(mx<0||my<0||mx>=MAP_W||my>=MAP_H) return '1';
    return maze[my][mx];
  }
  function castRay(x, y, angle) {
    let cos=Math.cos(angle), sin=Math.sin(angle);
    let dist=0, hit=false, type='0', maxDist=20, step=0.012;
    while(!hit && dist<maxDist) {
      let nx=x+cos*dist, ny=y+sin*dist;
      let mx=Math.floor(nx), my=Math.floor(ny);
      if(mx<0||my<0||mx>=MAP_W||my>=MAP_H) { hit=true; type='1'; }
      else if(maze[my][mx]=='1') { hit=true; type='1'; }
      else if(maze[my][mx]=='2') { hit=true; type='2'; }
      dist += step;
    }
    return {dist, type};
  }

  // ------ MOVEMENT: THICK WALL COLLISION ------
  function blockMovement(nx, ny) {
    for(let angle=0; angle<Math.PI*2; angle+=Math.PI/6){
      let px = nx + Math.cos(angle)*PLAYER.radius*0.98;
      let py = ny + Math.sin(angle)*PLAYER.radius*0.98;
      let wallType = wallAt(px, py);
      if(wallType=='1' || wallType=='2') return true;
    }
    return false;
  }

  // ------ RENDER 3D MAZE ------
  function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let pitchOffset = PLAYER.pitch * canvas.height * 0.34;

    // 3D walls from 2D maze map
    for(let i=0; i<NUM_RAYS; i++) {
      let rayAngle = PLAYER.dir - PLAYER.fov/2 + PLAYER.fov*i/NUM_RAYS;
      let {dist, type} = castRay(PLAYER.x, PLAYER.y, rayAngle);
      dist *= Math.cos(rayAngle-PLAYER.dir); // fisheye fix
      let wallHeight = canvas.height/(dist+0.1);
      if(type=='1') {
        let shade = Math.max(0, 180-dist*12);
        ctx.fillStyle = `rgb(${shade},0,0)`;
      } else if(type=='2') {
        ctx.fillStyle = "#fff";
      }
      ctx.fillRect(i*canvas.width/NUM_RAYS, canvas.height/2-wallHeight/2 + pitchOffset, canvas.width/NUM_RAYS+1, wallHeight);
    }

    // Monster billboard
    if(monster.active) {
      let dx=monster.x-PLAYER.x, dy=monster.y-PLAYER.y;
      let dist = Math.sqrt(dx*dx+dy*dy);
      let angToMonster = Math.atan2(dy,dx);
      let relAngle = angToMonster-PLAYER.dir;
      if(dist<20 && Math.abs(relAngle)<PLAYER.fov/2) {
        let px = (relAngle+PLAYER.fov/2)/PLAYER.fov*canvas.width;
        let size = monster.grabbing
          ? Math.min(canvas.height, 300/(dist+0.1) + monster.grabProgress*canvas.height*0.8)
          : Math.min(220, 500/(dist+0.1));
        ctx.save();
        ctx.globalAlpha = monster.grabbing ? 1 : Math.max(0.1, 0.8-dist/10);
        ctx.drawImage(monsterImage, px-size/2, canvas.height/2-size/2 + pitchOffset, size, size);
        ctx.restore();
      }
    }

    // Floor/ceiling
    ctx.fillStyle = "#222";
    ctx.fillRect(0,canvas.height/2+pitchOffset,canvas.width,canvas.height/2-pitchOffset);
    ctx.fillStyle = "#070707";
    ctx.fillRect(0,0,canvas.width,canvas.height/2+pitchOffset);
  }

  // ------ GAME LOGIC ------
  function update() {
    if (!PLAYER.alive) return;
    // Movement
    let moveX=0, moveY=0;
    if(keys["KeyW"]) { moveX+=Math.cos(PLAYER.dir)*PLAYER.speed; moveY+=Math.sin(PLAYER.dir)*PLAYER.speed; }
    if(keys["KeyS"]) { moveX-=Math.cos(PLAYER.dir)*PLAYER.speed; moveY-=Math.sin(PLAYER.dir)*PLAYER.speed; }
    if(keys["KeyA"]) { moveX+=Math.cos(PLAYER.dir-Math.PI/2)*PLAYER.speed; moveY+=Math.sin(PLAYER.dir-Math.PI/2)*PLAYER.speed; }
    if(keys["KeyD"]) { moveX+=Math.cos(PLAYER.dir+Math.PI/2)*PLAYER.speed; moveY+=Math.sin(PLAYER.dir+Math.PI/2)*PLAYER.speed; }
    let nx = PLAYER.x+moveX, ny = PLAYER.y+moveY;
    if(!blockMovement(nx, ny)) { PLAYER.x = nx; PLAYER.y = ny; }

    // Monster AI: thick wall collision
    if(monster.active && !monster.grabbing) {
      let dx = PLAYER.x-monster.x, dy = PLAYER.y-monster.y;
      let dist = Math.sqrt(dx*dx+dy*dy);
      let mx = monster.x + dx/dist*monster.speed;
      let my = monster.y + dy/dist*monster.speed;
      if(!blockMovement(mx, my)) { monster.x = mx; monster.y = my; }
      if(dist < PLAYER.radius+0.09) {
        monster.grabbing = true;
        monster.grabProgress = 0;
      }
    }
    // Grab/kill animation
    if(monster.grabbing) {
      monster.grabProgress += 0.025;
      if(monster.grabProgress >= 1) {
        monster.grabProgress = 1;
        killPlayer();
      }
    }
  }
  function killPlayer() {
    PLAYER.alive = false;
    document.getElementById('deathscreen').style.opacity = 1;
    document.getElementById('deathscreen').style.pointerEvents = 'auto';
  }

  // ------ MONSTER SPRITE ------
  const monsterImage = new Image();
  monsterImage.src = "data:image/svg+xml;base64," +
    btoa(`<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200">
      <ellipse cx="100" cy="110" rx="55" ry="80" fill="#222" stroke="black" stroke-width="8"/>
      <ellipse cx="100" cy="105" rx="45" ry="75" fill="black" stroke="limegreen" stroke-width="8"/>
      <ellipse cx="100" cy="165" rx="31" ry="8" fill="limegreen" stroke="black" stroke-width="2"/>
      <ellipse cx="100" cy="155" rx="17" ry="3" fill="red"/>
      <circle cx="80" cy="90" r="14" fill="white" stroke="black" stroke-width="4"/>
      <circle cx="120" cy="90" r="14" fill="white" stroke="black" stroke-width="4"/>
      <ellipse cx="80" cy="90" rx="7" ry="10" fill="red"/>
      <ellipse cx="120" cy="90" rx="7" ry="10" fill="red"/>
      <ellipse cx="100" cy="120" rx="37" ry="8" fill="black"/>
      <ellipse cx="100" cy="126" rx="25" ry="4" fill="#222"/>
      <ellipse cx="100" cy="135" rx="17" ry="5" fill="limegreen"/>
    </svg>`);

  // ------ MINIMAP ------
  const minimapCanvas = document.getElementById('minimap');
  const minimapCtx = minimapCanvas.getContext('2d');
  function renderMinimap() {
    minimapCtx.clearRect(0,0,minimapCanvas.width,minimapCanvas.height);
    let scale = Math.min(minimapCanvas.width/MAP_W, minimapCanvas.height/MAP_H);
    for(let y=0;y<MAP_H;y++)for(let x=0;x<MAP_W;x++){
      if(maze[y][x]=='1') minimapCtx.fillStyle='#a00';
      else if(maze[y][x]=='2') minimapCtx.fillStyle='#fff';
      else minimapCtx.fillStyle='#222';
      minimapCtx.fillRect(x*scale, y*scale, scale, scale);
    }
    // Player
    minimapCtx.beginPath();
    minimapCtx.arc(PLAYER.x*scale,PLAYER.y*scale,scale*0.5,0,Math.PI*2);
    minimapCtx.fillStyle='#0f0'; minimapCtx.fill();
    // Player facing
    minimapCtx.beginPath();
    minimapCtx.moveTo(PLAYER.x*scale,PLAYER.y*scale);
    minimapCtx.lineTo(
      (PLAYER.x+Math.cos(PLAYER.dir)*0.8)*scale,
      (PLAYER.y+Math.sin(PLAYER.dir)*0.8)*scale
    );
    minimapCtx.strokeStyle='#0f0'; minimapCtx.lineWidth=2; minimapCtx.stroke();
    // Monster
    minimapCtx.beginPath();
    minimapCtx.arc(monster.x*scale,monster.y*scale,scale*0.5,0,Math.PI*2);
    minimapCtx.fillStyle='#f00'; minimapCtx.fill();
  }

  // ------ PLAYER COORDS ------
  function renderCoords() {
    document.getElementById('coords').textContent =
      `Player: (${PLAYER.x.toFixed(2)}, ${PLAYER.y.toFixed(2)})`;
  }

  // ------ MAIN LOOP ------
  function gameLoop() {
    update();
    render();
    renderMinimap();
    renderCoords();
    requestAnimationFrame(gameLoop);
  }
  gameLoop();
  </script>
</body>
</html>
